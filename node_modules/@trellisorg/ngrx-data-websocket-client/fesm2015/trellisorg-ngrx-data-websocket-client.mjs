import * as i0 from '@angular/core';
import { Injectable, InjectionToken, Inject, NgModule } from '@angular/core';
import * as i1$1 from '@ngrx/effects';
import { createEffect, ofType, EffectsModule } from '@ngrx/effects';
import * as i1 from '@ngrx/data';
import { OP_SUCCESS, OP_ERROR, EntityCollectionServiceBase } from '@ngrx/data';
import * as i3 from '@ngrx/store';
import { ScannedActionsSubject } from '@ngrx/store';
import { filter, timeout, take, mergeMap, shareReplay, map, startWith } from 'rxjs/operators';
import { SocketOp, ROOT_ACTION_VALUE, listeners, dispatchEvents, reservedEvents } from '@trellisorg/ngrx-data-websocket-core';
import * as i4 from 'rxjs';
import { of, throwError, BehaviorSubject, merge } from 'rxjs';
import socketIo from 'socket.io-client';

function createActionType(entityName, op) {
    return `[${entityName}] ${op}`;
}

class SocketActionFactory {
    constructor(entityActionFactory) {
        this.entityActionFactory = entityActionFactory;
    }
    create(entityName, socketOp, data, options) {
        return {
            type: createActionType(entityName, socketOp),
            payload: Object.assign({ entityName,
                socketOp,
                data }, options),
        };
    }
    convertToDataAction(socketAction) {
        return this.entityActionFactory.create(socketAction.payload.entityName, socketAction.payload.socketOp.replace('ngrx-data-websocket', '@ngrx/data'), socketAction.payload.data);
    }
}
SocketActionFactory.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: SocketActionFactory, deps: [{ token: i1.EntityActionFactory }], target: i0.ɵɵFactoryTarget.Injectable });
SocketActionFactory.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: SocketActionFactory });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: SocketActionFactory, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.EntityActionFactory }]; } });

class SocketDataService {
    constructor(entityName, socketDispatcher) {
        this.entityName = entityName;
        this.socketDispatcher = socketDispatcher;
    }
    add(entity) {
        return this.socketDispatcher.add(entity);
    }
    delete(id) {
        return this.socketDispatcher.delete(id);
    }
    getAll() {
        return this.socketDispatcher.getAll();
    }
    getById(id) {
        return this.socketDispatcher.getById(id);
    }
    getWithQuery(params) {
        return this.socketDispatcher.getWithQuery(params);
    }
    update(update) {
        return this.socketDispatcher.update(update);
    }
    upsert(entity) {
        return this.socketDispatcher.upsert(entity);
    }
}

class SocketDataServiceFactory {
    create(entityName, dispatcher) {
        return new SocketDataService(entityName, dispatcher);
    }
}
SocketDataServiceFactory.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: SocketDataServiceFactory, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
SocketDataServiceFactory.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: SocketDataServiceFactory });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: SocketDataServiceFactory, decorators: [{
            type: Injectable
        }] });

const defaultNgrxDataWebsocketConfig = {
    timeout: 5000,
    host: '',
};
const NGRX_DATA_WEBSOCKET_CONFIG = new InjectionToken('ngrx-websocket-config');

class SocketDispatcherBase {
    constructor(entityName, correlationIdGenerator, socketActionFactory, reducedActions$, store, socketTimeout) {
        this.entityName = entityName;
        this.correlationIdGenerator = correlationIdGenerator;
        this.socketActionFactory = socketActionFactory;
        this.reducedActions$ = reducedActions$;
        this.store = store;
        this.socketTimeout = socketTimeout;
    }
    createSocketAction(socketOp, data, options) {
        return this.socketActionFactory.create(this.entityName, socketOp, data, options);
    }
    dispatch(action) {
        this.store.dispatch(action);
        return action;
    }
    add(entity) {
        return this.processEvent(SocketOp.SAVE_ADD_ONE, entity);
    }
    delete(id) {
        return this.processEvent(SocketOp.SAVE_DELETE_ONE, id);
    }
    getAll() {
        return this.processEvent(SocketOp.QUERY_ALL);
    }
    getById(id) {
        return this.processEvent(SocketOp.QUERY_BY_KEY, id);
    }
    getWithQuery(params) {
        return this.processEvent(SocketOp.QUERY_MANY, params);
    }
    update(update) {
        return this.processEvent(SocketOp.SAVE_UPDATE_ONE, update);
    }
    upsert(entity) {
        return this.processEvent(SocketOp.SAVE_UPSERT_ONE, entity);
    }
    processEvent(event, data) {
        const correlationId = this.correlationIdGenerator.next();
        const action = this.socketActionFactory.create(this.entityName, event, data, { correlationId });
        this.dispatch(action);
        return this.getResponseEventData$(correlationId);
    }
    getResponseEventData$(crid) {
        return this.reducedActions$.pipe(filter((act) => !!act.payload), filter((act) => {
            const { correlationId, entityName, socketOp } = act.payload;
            return (entityName === this.entityName &&
                correlationId === crid &&
                (socketOp.endsWith(OP_SUCCESS) ||
                    socketOp.endsWith(OP_ERROR)));
        }), timeout(this.socketTimeout), take(1), mergeMap((act) => {
            const { socketOp } = act.payload;
            return socketOp.endsWith(OP_SUCCESS)
                ? of(act.payload.data)
                : throwError(act.payload.data.error);
        }));
    }
}

class SocketDispatcherFactory {
    constructor(scannedActions$, config, correlationIdGenerator, socketActionFactory, store) {
        this.config = config;
        this.correlationIdGenerator = correlationIdGenerator;
        this.socketActionFactory = socketActionFactory;
        this.store = store;
        this.reducedActions$ = scannedActions$.pipe(shareReplay(1));
        this.raSubscription = this.reducedActions$.subscribe();
    }
    create(entityName) {
        return new SocketDispatcherBase(entityName, this.correlationIdGenerator, this.socketActionFactory, this.reducedActions$, this.store, isNaN(this.config.timeout)
            ? defaultNgrxDataWebsocketConfig.timeout
            : this.config.timeout);
    }
    ngOnDestroy() {
        this.raSubscription.unsubscribe();
    }
}
SocketDispatcherFactory.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: SocketDispatcherFactory, deps: [{ token: ScannedActionsSubject }, { token: NGRX_DATA_WEBSOCKET_CONFIG }, { token: i1.CorrelationIdGenerator }, { token: SocketActionFactory }, { token: i3.Store }], target: i0.ɵɵFactoryTarget.Injectable });
SocketDispatcherFactory.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: SocketDispatcherFactory });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: SocketDispatcherFactory, decorators: [{
            type: Injectable
        }], ctorParameters: function () {
        return [{ type: i4.Observable, decorators: [{
                        type: Inject,
                        args: [ScannedActionsSubject]
                    }] }, { type: undefined, decorators: [{
                        type: Inject,
                        args: [NGRX_DATA_WEBSOCKET_CONFIG]
                    }] }, { type: i1.CorrelationIdGenerator }, { type: SocketActionFactory }, { type: i3.Store }];
    } });

function ofSocketType(...allowedActions) {
    return filter((action) => allowedActions.some((socketOp) => {
        return action.type.includes(ROOT_ACTION_VALUE);
    }));
}

class SocketEventListenerCollectionService {
    constructor() {
        this.listeners = new Map();
    }
    register(entityName, listener) {
        this.listeners.set(entityName, listener);
    }
    get(entityName) {
        return this.listeners.get(entityName);
    }
}
SocketEventListenerCollectionService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: SocketEventListenerCollectionService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
SocketEventListenerCollectionService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: SocketEventListenerCollectionService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: SocketEventListenerCollectionService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return []; } });

class SocketDispatcherEffects {
    constructor(_actions$, socketEventListenerCollectionService, socketActionFactory) {
        this._actions$ = _actions$;
        this.socketEventListenerCollectionService = socketEventListenerCollectionService;
        this.socketActionFactory = socketActionFactory;
        this.socketEventWithoutCrid$ = createEffect(() => this._actions$.pipe(ofSocketType(...listeners), filter((action) => !action.payload.correlationId), map((action) => this.socketActionFactory.convertToDataAction(action))));
        this.dispatchSocketEvent$ = createEffect(() => this._actions$.pipe(ofSocketType(...dispatchEvents), map((action) => action.payload), map((action) => {
            const listener = this.socketEventListenerCollectionService.get(action.entityName);
            if (listener) {
                listener.emit(action.socketOp, action.correlationId, action.data);
            }
            return;
        })), { dispatch: false });
    }
}
SocketDispatcherEffects.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: SocketDispatcherEffects, deps: [{ token: i1$1.Actions }, { token: SocketEventListenerCollectionService }, { token: SocketActionFactory }], target: i0.ɵɵFactoryTarget.Injectable });
SocketDispatcherEffects.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: SocketDispatcherEffects });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: SocketDispatcherEffects, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$1.Actions }, { type: SocketEventListenerCollectionService }, { type: SocketActionFactory }]; } });

class SocketEventListener {
    constructor(entityName, socketActionFactory, store) {
        this.socketActionFactory = socketActionFactory;
        this.store = store;
        this._entityName = entityName;
    }
    setupReservedEvents() {
        [SocketOp.CONNECT_ERROR, SocketOp.RECONNECT_ERROR].forEach((event) => this._socket.on(event, (err) => this.store.dispatch(this.socketActionFactory.create(this._entityName, event, err))));
        [
            SocketOp.CONNECT_TIMEOUT,
            SocketOp.RECONNECT_ATTEMPT,
            SocketOp.RECONNECT_FAILED,
        ].forEach((event) => this._socket.on(event, (attempts) => this.store.dispatch(this.socketActionFactory.create(this._entityName, event, attempts))));
        [SocketOp.RECONNECT, SocketOp.RECONNECTING].forEach((event) => this._socket.on(event, () => this.store.dispatch(this.socketActionFactory.create(this._entityName, event))));
    }
    emit(event, crid, data) {
        this._socket.emit(event, {
            correlationId: crid,
            data,
        });
    }
    disconnect() {
        this._socket.disconnect();
    }
    connect(config, params) {
        const connected = new BehaviorSubject(false);
        const host = config.host ? `${config.host}/` : '';
        const connectParams = new URLSearchParams(params).toString();
        this._socket = socketIo(`${host}${this._entityName.toLowerCase()}?${connectParams}`, {
            transports: ['websocket', 'polling'],
        });
        this.setupReservedEvents();
        this._socket.on('connect', () => {
            this.store.dispatch(this.socketActionFactory.create(this._entityName, SocketOp.CONNECT));
            connected.next(true);
            connected.complete();
        });
        listeners.forEach((event) => {
            this._socket.on(event, (response) => {
                const { correlationId, data } = response;
                this.store.dispatch(this.socketActionFactory.create(this._entityName, event, data, {
                    correlationId,
                }));
            });
        });
        return connected.asObservable();
    }
}

class SocketEventListenerFactory {
    constructor(socketActionFactory, store) {
        this.socketActionFactory = socketActionFactory;
        this.store = store;
    }
    create(entityName) {
        return new SocketEventListener(entityName, this.socketActionFactory, this.store);
    }
}
SocketEventListenerFactory.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: SocketEventListenerFactory, deps: [{ token: SocketActionFactory }, { token: i3.Store }], target: i0.ɵɵFactoryTarget.Injectable });
SocketEventListenerFactory.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: SocketEventListenerFactory });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: SocketEventListenerFactory, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: SocketActionFactory }, { type: i3.Store }]; } });

class SocketSelectors$Factory {
    constructor(store, actions) {
        this.store = store;
        this.actions = actions;
    }
    create(entityName) {
        // This will filter actions by only the socket.io reserved events
        const reservedActions$ = this.actions.pipe(ofType(...reservedEvents.map((event) => createActionType(entityName, event))));
        // Defaults to true since sockets try to connect right away
        const connectingOrReconnecting = reservedActions$.pipe(ofType(createActionType(entityName, SocketOp.RECONNECTING)), map(() => true), startWith(true), shareReplay(1));
        const connectFailed = reservedActions$.pipe(ofType(...[
            SocketOp.CONNECT_ERROR,
            SocketOp.CONNECT_TIMEOUT,
            SocketOp.RECONNECT_ERROR,
            SocketOp.RECONNECT_FAILED,
        ].map((op) => createActionType(entityName, op))), map(() => true), shareReplay(1));
        const connectOrReconnect = reservedActions$.pipe(ofType(...[SocketOp.CONNECT, SocketOp.RECONNECT].map((op) => createActionType(entityName, op))), map(() => true), shareReplay(1));
        /**
         * Socket is connected if:
         * CONNECT or RECONNECT has been emitted
         * but not if ERROR or TIMEOUT events emitted
         * and if the socket is not currently connecting
         */
        const connected$ = merge(connectOrReconnect, connectFailed.pipe(map((val) => !val)), connectingOrReconnecting.pipe(map((val) => !val)));
        /**
         * Currently connecting if initial value is used or RECONNECTING event is emitted
         * but not if it has failed or a CONNECT or RECONNECT event has been emitted
         */
        const connecting$ = merge(connectingOrReconnecting, connectFailed.pipe(map((val) => !val)), connectOrReconnect.pipe(map((val) => !val)));
        return {
            connected$,
            connecting$,
        };
    }
}
SocketSelectors$Factory.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: SocketSelectors$Factory, deps: [{ token: i3.Store }, { token: i1$1.Actions }], target: i0.ɵɵFactoryTarget.Injectable });
SocketSelectors$Factory.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: SocketSelectors$Factory });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: SocketSelectors$Factory, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i3.Store }, { type: i1$1.Actions }]; } });

class SocketServiceElementsFactory {
    constructor(config, socketDispatcherFactory, socketEventListenerFactory, socketDataServiceFactory, entityDataService, socketEventListenerCollectionService, socketSelectors$Factory) {
        this.config = config;
        this.socketDispatcherFactory = socketDispatcherFactory;
        this.socketEventListenerFactory = socketEventListenerFactory;
        this.socketDataServiceFactory = socketDataServiceFactory;
        this.entityDataService = entityDataService;
        this.socketEventListenerCollectionService = socketEventListenerCollectionService;
        this.socketSelectors$Factory = socketSelectors$Factory;
    }
    create(entityName) {
        const dispatcher = this.socketDispatcherFactory.create(entityName);
        const listener = this.socketEventListenerFactory.create(entityName);
        const selectors$ = this.socketSelectors$Factory.create(entityName);
        this.socketEventListenerCollectionService.register(entityName, listener);
        const dataService = this.socketDataServiceFactory.create(entityName, dispatcher);
        this.entityDataService.registerService(entityName, dataService);
        return {
            listener,
            dispatcher,
            entityName,
            dataService,
            selectors$,
        };
    }
}
SocketServiceElementsFactory.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: SocketServiceElementsFactory, deps: [{ token: NGRX_DATA_WEBSOCKET_CONFIG }, { token: SocketDispatcherFactory }, { token: SocketEventListenerFactory }, { token: SocketDataServiceFactory }, { token: i1.EntityDataService }, { token: SocketEventListenerCollectionService }, { token: SocketSelectors$Factory }], target: i0.ɵɵFactoryTarget.Injectable });
SocketServiceElementsFactory.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: SocketServiceElementsFactory });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: SocketServiceElementsFactory, decorators: [{
            type: Injectable
        }], ctorParameters: function () {
        return [{ type: undefined, decorators: [{
                        type: Inject,
                        args: [NGRX_DATA_WEBSOCKET_CONFIG]
                    }] }, { type: SocketDispatcherFactory }, { type: SocketEventListenerFactory }, { type: SocketDataServiceFactory }, { type: i1.EntityDataService }, { type: SocketEventListenerCollectionService }, { type: SocketSelectors$Factory }];
    } });

class NgrxDataWebsocketClientModule {
    constructor(effectsSources, socketDispatcherEffects) {
        this.effectsSources = effectsSources;
        this.socketDispatcherEffects = socketDispatcherEffects;
        this.effectsSources.addEffects(socketDispatcherEffects);
    }
    static forRoot(config) {
        return {
            ngModule: NgrxDataWebsocketClientModule,
            providers: [
                {
                    provide: NGRX_DATA_WEBSOCKET_CONFIG,
                    useValue: Object.assign(Object.assign({}, defaultNgrxDataWebsocketConfig), config),
                },
            ],
        };
    }
}
NgrxDataWebsocketClientModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: NgrxDataWebsocketClientModule, deps: [{ token: i1$1.EffectSources }, { token: SocketDispatcherEffects }], target: i0.ɵɵFactoryTarget.NgModule });
NgrxDataWebsocketClientModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "14.0.0", ngImport: i0, type: NgrxDataWebsocketClientModule, imports: [EffectsModule] });
NgrxDataWebsocketClientModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: NgrxDataWebsocketClientModule, providers: [
        SocketServiceElementsFactory,
        SocketDispatcherFactory,
        SocketActionFactory,
        SocketDataServiceFactory,
        SocketEventListenerFactory,
        SocketEventListenerCollectionService,
        SocketDispatcherEffects,
        SocketSelectors$Factory,
    ], imports: [EffectsModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: NgrxDataWebsocketClientModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [EffectsModule],
                    providers: [
                        SocketServiceElementsFactory,
                        SocketDispatcherFactory,
                        SocketActionFactory,
                        SocketDataServiceFactory,
                        SocketEventListenerFactory,
                        SocketEventListenerCollectionService,
                        SocketDispatcherEffects,
                        SocketSelectors$Factory,
                    ],
                }]
        }], ctorParameters: function () { return [{ type: i1$1.EffectSources }, { type: SocketDispatcherEffects }]; } });

class SocketCollectionServiceBase extends EntityCollectionServiceBase {
    constructor(entityName, serviceElementsFactory, socketServiceElementsFactory) {
        super(entityName, serviceElementsFactory);
        this.socketServiceElementsFactory = socketServiceElementsFactory;
        const { listener, selectors$ } = socketServiceElementsFactory.create(entityName);
        this.connected$ = selectors$.connected$;
        this.connecting$ = selectors$.connecting$;
        this.listener = listener;
    }
    connect(params) {
        return this.listener.connect(this.socketServiceElementsFactory.config, params);
    }
    disconnect() {
        this.listener.disconnect();
    }
}

/**
 * Generated bundle index. Do not edit.
 */

export { NgrxDataWebsocketClientModule, SocketCollectionServiceBase, SocketServiceElementsFactory };
//# sourceMappingURL=trellisorg-ngrx-data-websocket-client.mjs.map
