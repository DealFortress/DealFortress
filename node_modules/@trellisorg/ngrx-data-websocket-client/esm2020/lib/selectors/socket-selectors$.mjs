import { Injectable } from '@angular/core';
import { Actions, ofType } from '@ngrx/effects';
import { Store } from '@ngrx/store';
import { reservedEvents, SocketOp, } from '@trellisorg/ngrx-data-websocket-core';
import { merge } from 'rxjs';
import { map, shareReplay, startWith } from 'rxjs/operators';
import { createActionType } from '../utils/create-action-type';
import * as i0 from "@angular/core";
import * as i1 from "@ngrx/store";
import * as i2 from "@ngrx/effects";
export class SocketSelectors$Factory {
    constructor(store, actions) {
        this.store = store;
        this.actions = actions;
    }
    create(entityName) {
        // This will filter actions by only the socket.io reserved events
        const reservedActions$ = this.actions.pipe(ofType(...reservedEvents.map((event) => createActionType(entityName, event))));
        // Defaults to true since sockets try to connect right away
        const connectingOrReconnecting = reservedActions$.pipe(ofType(createActionType(entityName, SocketOp.RECONNECTING)), map(() => true), startWith(true), shareReplay(1));
        const connectFailed = reservedActions$.pipe(ofType(...[
            SocketOp.CONNECT_ERROR,
            SocketOp.CONNECT_TIMEOUT,
            SocketOp.RECONNECT_ERROR,
            SocketOp.RECONNECT_FAILED,
        ].map((op) => createActionType(entityName, op))), map(() => true), shareReplay(1));
        const connectOrReconnect = reservedActions$.pipe(ofType(...[SocketOp.CONNECT, SocketOp.RECONNECT].map((op) => createActionType(entityName, op))), map(() => true), shareReplay(1));
        /**
         * Socket is connected if:
         * CONNECT or RECONNECT has been emitted
         * but not if ERROR or TIMEOUT events emitted
         * and if the socket is not currently connecting
         */
        const connected$ = merge(connectOrReconnect, connectFailed.pipe(map((val) => !val)), connectingOrReconnecting.pipe(map((val) => !val)));
        /**
         * Currently connecting if initial value is used or RECONNECTING event is emitted
         * but not if it has failed or a CONNECT or RECONNECT event has been emitted
         */
        const connecting$ = merge(connectingOrReconnecting, connectFailed.pipe(map((val) => !val)), connectOrReconnect.pipe(map((val) => !val)));
        return {
            connected$,
            connecting$,
        };
    }
}
SocketSelectors$Factory.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: SocketSelectors$Factory, deps: [{ token: i1.Store }, { token: i2.Actions }], target: i0.ɵɵFactoryTarget.Injectable });
SocketSelectors$Factory.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: SocketSelectors$Factory });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: SocketSelectors$Factory, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.Store }, { type: i2.Actions }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29ja2V0LXNlbGVjdG9ycyQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9uZ3J4LWRhdGEtd2Vic29ja2V0L2NsaWVudC9zcmMvbGliL3NlbGVjdG9ycy9zb2NrZXQtc2VsZWN0b3JzJC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2hELE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDcEMsT0FBTyxFQUNILGNBQWMsRUFFZCxRQUFRLEdBQ1gsTUFBTSxzQ0FBc0MsQ0FBQztBQUM5QyxPQUFPLEVBQUUsS0FBSyxFQUFjLE1BQU0sTUFBTSxDQUFDO0FBQ3pDLE9BQU8sRUFBRSxHQUFHLEVBQUUsV0FBVyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzdELE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLDZCQUE2QixDQUFDOzs7O0FBUy9ELE1BQU0sT0FBTyx1QkFBdUI7SUFDaEMsWUFBb0IsS0FBWSxFQUFVLE9BQThCO1FBQXBELFVBQUssR0FBTCxLQUFLLENBQU87UUFBVSxZQUFPLEdBQVAsT0FBTyxDQUF1QjtJQUFHLENBQUM7SUFFNUUsTUFBTSxDQUFJLFVBQWtCO1FBQ3hCLGlFQUFpRTtRQUNqRSxNQUFNLGdCQUFnQixHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUN0QyxNQUFNLENBQ0YsR0FBRyxjQUFjLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FDNUIsZ0JBQWdCLENBQUMsVUFBVSxFQUFFLEtBQUssQ0FBQyxDQUN0QyxDQUNKLENBQ0osQ0FBQztRQUVGLDJEQUEyRDtRQUMzRCxNQUFNLHdCQUF3QixHQUF3QixnQkFBZ0IsQ0FBQyxJQUFJLENBQ3ZFLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLEVBQUUsUUFBUSxDQUFDLFlBQVksQ0FBQyxDQUFDLEVBQzNELEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFDZixTQUFTLENBQUMsSUFBSSxDQUFDLEVBQ2YsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUNqQixDQUFDO1FBRUYsTUFBTSxhQUFhLEdBQXdCLGdCQUFnQixDQUFDLElBQUksQ0FDNUQsTUFBTSxDQUNGLEdBQUc7WUFDQyxRQUFRLENBQUMsYUFBYTtZQUN0QixRQUFRLENBQUMsZUFBZTtZQUN4QixRQUFRLENBQUMsZUFBZTtZQUN4QixRQUFRLENBQUMsZ0JBQWdCO1NBQzVCLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FDbEQsRUFDRCxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQ2YsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUNqQixDQUFDO1FBRUYsTUFBTSxrQkFBa0IsR0FBd0IsZ0JBQWdCLENBQUMsSUFBSSxDQUNqRSxNQUFNLENBQ0YsR0FBRyxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUUsUUFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQ2pELGdCQUFnQixDQUFDLFVBQVUsRUFBRSxFQUFFLENBQUMsQ0FDbkMsQ0FDSixFQUNELEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFDZixXQUFXLENBQUMsQ0FBQyxDQUFDLENBQ2pCLENBQUM7UUFFRjs7Ozs7V0FLRztRQUNILE1BQU0sVUFBVSxHQUF3QixLQUFLLENBQ3pDLGtCQUFrQixFQUNsQixhQUFhLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUN0Qyx3QkFBd0IsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQ3BELENBQUM7UUFFRjs7O1dBR0c7UUFDSCxNQUFNLFdBQVcsR0FBd0IsS0FBSyxDQUMxQyx3QkFBd0IsRUFDeEIsYUFBYSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFDdEMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUM5QyxDQUFDO1FBRUYsT0FBTztZQUNILFVBQVU7WUFDVixXQUFXO1NBQ2QsQ0FBQztJQUNOLENBQUM7O29IQXRFUSx1QkFBdUI7d0hBQXZCLHVCQUF1QjsyRkFBdkIsdUJBQXVCO2tCQURuQyxVQUFVIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQWN0aW9ucywgb2ZUeXBlIH0gZnJvbSAnQG5ncngvZWZmZWN0cyc7XG5pbXBvcnQgeyBTdG9yZSB9IGZyb20gJ0BuZ3J4L3N0b3JlJztcbmltcG9ydCB7XG4gICAgcmVzZXJ2ZWRFdmVudHMsXG4gICAgU29ja2V0QWN0aW9uLFxuICAgIFNvY2tldE9wLFxufSBmcm9tICdAdHJlbGxpc29yZy9uZ3J4LWRhdGEtd2Vic29ja2V0LWNvcmUnO1xuaW1wb3J0IHsgbWVyZ2UsIE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCwgc2hhcmVSZXBsYXksIHN0YXJ0V2l0aCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IGNyZWF0ZUFjdGlvblR5cGUgfSBmcm9tICcuLi91dGlscy9jcmVhdGUtYWN0aW9uLXR5cGUnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNvY2tldFNlbGVjdG9ycyQ8VD4ge1xuICAgIHJlYWRvbmx5IGNvbm5lY3RlZCQ6IE9ic2VydmFibGU8Ym9vbGVhbj47XG5cbiAgICByZWFkb25seSBjb25uZWN0aW5nJDogT2JzZXJ2YWJsZTxib29sZWFuPjtcbn1cblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFNvY2tldFNlbGVjdG9ycyRGYWN0b3J5PFQ+IHtcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHN0b3JlOiBTdG9yZSwgcHJpdmF0ZSBhY3Rpb25zOiBBY3Rpb25zPFNvY2tldEFjdGlvbj4pIHt9XG5cbiAgICBjcmVhdGU8VD4oZW50aXR5TmFtZTogc3RyaW5nKTogU29ja2V0U2VsZWN0b3JzJDxUPiB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCBmaWx0ZXIgYWN0aW9ucyBieSBvbmx5IHRoZSBzb2NrZXQuaW8gcmVzZXJ2ZWQgZXZlbnRzXG4gICAgICAgIGNvbnN0IHJlc2VydmVkQWN0aW9ucyQgPSB0aGlzLmFjdGlvbnMucGlwZShcbiAgICAgICAgICAgIG9mVHlwZShcbiAgICAgICAgICAgICAgICAuLi5yZXNlcnZlZEV2ZW50cy5tYXAoKGV2ZW50KSA9PlxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVBY3Rpb25UeXBlKGVudGl0eU5hbWUsIGV2ZW50KVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBEZWZhdWx0cyB0byB0cnVlIHNpbmNlIHNvY2tldHMgdHJ5IHRvIGNvbm5lY3QgcmlnaHQgYXdheVxuICAgICAgICBjb25zdCBjb25uZWN0aW5nT3JSZWNvbm5lY3Rpbmc6IE9ic2VydmFibGU8Ym9vbGVhbj4gPSByZXNlcnZlZEFjdGlvbnMkLnBpcGUoXG4gICAgICAgICAgICBvZlR5cGUoY3JlYXRlQWN0aW9uVHlwZShlbnRpdHlOYW1lLCBTb2NrZXRPcC5SRUNPTk5FQ1RJTkcpKSxcbiAgICAgICAgICAgIG1hcCgoKSA9PiB0cnVlKSxcbiAgICAgICAgICAgIHN0YXJ0V2l0aCh0cnVlKSxcbiAgICAgICAgICAgIHNoYXJlUmVwbGF5KDEpXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgY29ubmVjdEZhaWxlZDogT2JzZXJ2YWJsZTxib29sZWFuPiA9IHJlc2VydmVkQWN0aW9ucyQucGlwZShcbiAgICAgICAgICAgIG9mVHlwZShcbiAgICAgICAgICAgICAgICAuLi5bXG4gICAgICAgICAgICAgICAgICAgIFNvY2tldE9wLkNPTk5FQ1RfRVJST1IsXG4gICAgICAgICAgICAgICAgICAgIFNvY2tldE9wLkNPTk5FQ1RfVElNRU9VVCxcbiAgICAgICAgICAgICAgICAgICAgU29ja2V0T3AuUkVDT05ORUNUX0VSUk9SLFxuICAgICAgICAgICAgICAgICAgICBTb2NrZXRPcC5SRUNPTk5FQ1RfRkFJTEVELFxuICAgICAgICAgICAgICAgIF0ubWFwKChvcCkgPT4gY3JlYXRlQWN0aW9uVHlwZShlbnRpdHlOYW1lLCBvcCkpXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgbWFwKCgpID0+IHRydWUpLFxuICAgICAgICAgICAgc2hhcmVSZXBsYXkoMSlcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBjb25uZWN0T3JSZWNvbm5lY3Q6IE9ic2VydmFibGU8Ym9vbGVhbj4gPSByZXNlcnZlZEFjdGlvbnMkLnBpcGUoXG4gICAgICAgICAgICBvZlR5cGUoXG4gICAgICAgICAgICAgICAgLi4uW1NvY2tldE9wLkNPTk5FQ1QsIFNvY2tldE9wLlJFQ09OTkVDVF0ubWFwKChvcCkgPT5cbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlQWN0aW9uVHlwZShlbnRpdHlOYW1lLCBvcClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgbWFwKCgpID0+IHRydWUpLFxuICAgICAgICAgICAgc2hhcmVSZXBsYXkoMSlcbiAgICAgICAgKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU29ja2V0IGlzIGNvbm5lY3RlZCBpZjpcbiAgICAgICAgICogQ09OTkVDVCBvciBSRUNPTk5FQ1QgaGFzIGJlZW4gZW1pdHRlZFxuICAgICAgICAgKiBidXQgbm90IGlmIEVSUk9SIG9yIFRJTUVPVVQgZXZlbnRzIGVtaXR0ZWRcbiAgICAgICAgICogYW5kIGlmIHRoZSBzb2NrZXQgaXMgbm90IGN1cnJlbnRseSBjb25uZWN0aW5nXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBjb25uZWN0ZWQkOiBPYnNlcnZhYmxlPGJvb2xlYW4+ID0gbWVyZ2UoXG4gICAgICAgICAgICBjb25uZWN0T3JSZWNvbm5lY3QsXG4gICAgICAgICAgICBjb25uZWN0RmFpbGVkLnBpcGUobWFwKCh2YWwpID0+ICF2YWwpKSxcbiAgICAgICAgICAgIGNvbm5lY3RpbmdPclJlY29ubmVjdGluZy5waXBlKG1hcCgodmFsKSA9PiAhdmFsKSlcbiAgICAgICAgKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3VycmVudGx5IGNvbm5lY3RpbmcgaWYgaW5pdGlhbCB2YWx1ZSBpcyB1c2VkIG9yIFJFQ09OTkVDVElORyBldmVudCBpcyBlbWl0dGVkXG4gICAgICAgICAqIGJ1dCBub3QgaWYgaXQgaGFzIGZhaWxlZCBvciBhIENPTk5FQ1Qgb3IgUkVDT05ORUNUIGV2ZW50IGhhcyBiZWVuIGVtaXR0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGNvbm5lY3RpbmckOiBPYnNlcnZhYmxlPGJvb2xlYW4+ID0gbWVyZ2UoXG4gICAgICAgICAgICBjb25uZWN0aW5nT3JSZWNvbm5lY3RpbmcsXG4gICAgICAgICAgICBjb25uZWN0RmFpbGVkLnBpcGUobWFwKCh2YWwpID0+ICF2YWwpKSxcbiAgICAgICAgICAgIGNvbm5lY3RPclJlY29ubmVjdC5waXBlKG1hcCgodmFsKSA9PiAhdmFsKSlcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29ubmVjdGVkJCxcbiAgICAgICAgICAgIGNvbm5lY3RpbmckLFxuICAgICAgICB9O1xuICAgIH1cbn1cbiJdfQ==